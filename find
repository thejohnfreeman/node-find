#!/usr/bin/env NODE_PATH=.:$NODE_PATH node

var find    = require('.')
var debug   = require('gulp-debug')
var drain   = require('./drain')
var through = require('through2')
var args    = require('./args')

var argv = require('yargs')
.demand(1)
.usage('$0 [options] path [path...]\n\n'
  + 'All filters like name, path, and regex will be taken as a disjunction.')
.describe('max-depth', 'Limit depth of recursion.')
.alias('insensitive', 'i')
.describe('insensitive', 'Turn off case sensitivity.')
.describe('type', 'True if the file is of the given type.')
.describe('name',
  'True if given glob pattern matches the last component of the path.')
.describe('path',
  'True if given glob pattern matches the full path.'
  + ' Wildcards match directory separators.')
.describe('regex',
  'True if given regex matches the full path.')
.describe('prune.{name|path|regex}',
  'False if matches any component of the path.'
  + ' Used to avoid traversing branches of the tree.')
.help('help', 'Show this help and exit.')
.wrap(80)
.argv

var opts = argv

opts.start = argv._

var constTrue = function() { return true }
var constFalse = function() { return false }

var pathMatch = args.compilePathMatch(opts) || constTrue
var typeMatch = args.compileTypeMatch(opts) || constTrue
opts.filter = function(path, stats) {
  return pathMatch(path) && typeMatch(stats)
}

opts.prune = args.compilePathMatch(opts.prune || {}) || constFalse

find(opts)
.pipe(through.obj(function(entry, enc, next) {
  console.log(entry.path)
  next()
}))
.pipe(drain.objs)

